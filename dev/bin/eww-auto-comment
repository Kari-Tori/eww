#!/usr/bin/env bash
# eww-auto-comment - Automatyczne generowanie komentarzy do kodu
# Dodaje opisowe komentarze do funkcji i sekcji kodu

set -euo pipefail

# Kolory
readonly GREEN='\033[0;32m'
readonly BLUE='\033[0;34m'
readonly YELLOW='\033[1;33m'
readonly NC='\033[0m'

log_info() {
    echo -e "${BLUE}ℹ${NC} $*" >&2
}

log_success() {
    echo -e "${GREEN}✓${NC} $*" >&2
}

log_warn() {
    echo -e "${YELLOW}⚠${NC} $*" >&2
}

usage() {
    cat <<EOF
Użycie: eww-auto-comment [OPCJE] PLIK

Automatyczne dodawanie komentarzy do kodu Bash.

OPCJE:
    -h, --help          Wyświetl tę pomoc
    -d, --dry-run       Tylko wyświetl, nie zapisuj
    -f, --force         Nadpisz istniejące komentarze
    -s, --style STYL    Styl komentarzy: simple|detailed|doxygen (domyślnie: simple)

PRZYKŁADY:
    # Dodaj komentarze do skryptu
    eww-auto-comment lib/git.sh

    # Podgląd bez zapisywania
    eww-auto-comment --dry-run scripts/version.sh

    # Szczegółowe komentarze w stylu doxygen
    eww-auto-comment --style doxygen bin/eww-status
EOF
}

# Wykryj funkcje w pliku bash
detect_functions() {
    local file="$1"
    # Wykrywa funkcje w formacie: function_name() { lub function function_name {
    grep -nE '^[[:space:]]*(function[[:space:]]+)?[a-zA-Z_][a-zA-Z0-9_:]*[[:space:]]*\(\)[[:space:]]*\{' "$file" || true
}

# Generuj komentarz dla funkcji (prosty styl)
generate_simple_comment() {
    local func_name="$1"
    local clean_name="${func_name//::/ }"
    clean_name="${clean_name//_/ }"
    
    cat <<EOF
# ${clean_name^}
EOF
}

# Generuj komentarz szczegółowy
generate_detailed_comment() {
    local func_name="$1"
    
    cat <<EOF
#
# Funkcja: ${func_name}
# Opis: [TODO: Dodaj opis]
# Argumenty:
#   \$1 - [TODO: Opis parametru]
# Zwraca: 0 w przypadku sukcesu, kod błędu w przeciwnym razie
#
EOF
}

# Generuj komentarz w stylu doxygen
generate_doxygen_comment() {
    local func_name="$1"
    
    cat <<EOF
##
# @brief [TODO: Krótki opis funkcji]
# @details [TODO: Szczegółowy opis funkcji]
# 
# @param \$1 [TODO: Opis parametru]
# @return 0 w przypadku sukcesu, kod błędu w przeciwnym razie
# 
# @example
#   ${func_name} arg1 arg2
##
EOF
}

# Sprawdź czy funkcja ma już komentarz
has_comment() {
    local file="$1"
    local line_num="$2"
    
    # Sprawdź czy linia powyżej zawiera komentarz
    local prev_line=$((line_num - 1))
    if [[ $prev_line -gt 0 ]]; then
        local prev_content=$(sed -n "${prev_line}p" "$file")
        [[ $prev_content =~ ^[[:space:]]*# ]]
    else
        return 1
    fi
}

# Dodaj komentarze do pliku
add_comments() {
    local file="$1"
    local style="${2:-simple}"
    local force="${3:-false}"
    local dry_run="${4:-false}"
    
    if [[ ! -f $file ]]; then
        log_warn "Plik nie istnieje: $file"
        return 1
    fi
    
    local functions=$(detect_functions "$file")
    
    if [[ -z $functions ]]; then
        log_warn "Nie znaleziono funkcji w pliku: $file"
        return 0
    fi
    
    local tmp_file=$(mktemp)
    cp "$file" "$tmp_file"
    
    local added_count=0
    local skipped_count=0
    
    # Przetwarzanie od końca pliku (aby numery linii się nie zmieniały)
    while IFS=: read -r line_num func_line; do
        # Wyciągnij nazwę funkcji
        local func_name=$(echo "$func_line" | sed -E 's/^[[:space:]]*(function[[:space:]]+)?([a-zA-Z_][a-zA-Z0-9_:]*).*/\2/')
        
        if has_comment "$tmp_file" "$line_num" && [[ $force != true ]]; then
            log_info "Pomijam ${func_name} (ma już komentarz)"
            ((skipped_count++))
            continue
        fi
        
        # Generuj komentarz według stylu
        local comment
        case $style in
            detailed)
                comment=$(generate_detailed_comment "$func_name")
                ;;
            doxygen)
                comment=$(generate_doxygen_comment "$func_name")
                ;;
            *)
                comment=$(generate_simple_comment "$func_name")
                ;;
        esac
        
        # Wstaw komentarz przed funkcją
        sed -i "${line_num}i\\${comment}" "$tmp_file"
        log_success "Dodano komentarz do: ${func_name}"
        ((added_count++))
        
    done < <(echo "$functions" | tac)  # tac = odwrócona kolejność
    
    if [[ $dry_run == true ]]; then
        echo "=== Podgląd (dry-run) ==="
        cat "$tmp_file"
        rm "$tmp_file"
    else
        mv "$tmp_file" "$file"
        log_success "Zaktualizowano plik: $file"
    fi
    
    echo ""
    log_info "Statystyki: dodano ${added_count}, pominięto ${skipped_count}"
}

# Main
main() {
    local file=""
    local style="simple"
    local force=false
    local dry_run=false
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                usage
                exit 0
                ;;
            -d|--dry-run)
                dry_run=true
                shift
                ;;
            -f|--force)
                force=true
                shift
                ;;
            -s|--style)
                style="$2"
                shift 2
                ;;
            -*)
                echo "Nieznana opcja: $1"
                usage
                exit 1
                ;;
            *)
                file="$1"
                shift
                ;;
        esac
    done
    
    if [[ -z $file ]]; then
        echo "Błąd: nie podano pliku"
        usage
        exit 1
    fi
    
    add_comments "$file" "$style" "$force" "$dry_run"
}

main "$@"
